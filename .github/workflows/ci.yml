name: CI

permissions:
  contents: read
  pull-requests: write

on:
  push:
    branches: ["main"]
  pull_request:
    branches: ["main"]
    types: [
      opened,
      reopened,
      closed,
      synchronize,
      ready_for_review,
      labeled,
      unlabeled
    ]
  workflow_dispatch: {}

jobs:
  lint-and-build:
    runs-on: ubuntu-latest
    permissions: write-all
    strategy:
      matrix:
        node-version: [18.x]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch full history for version tagging

      - name: Query version tags and determine next version
        id: version
        run: |
          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Get the latest version tag (semantic versioning)
          LATEST_TAG=$(git tag -l | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' | sort -V | tail -1)
          
          if [ -z "$LATEST_TAG" ]; then
            echo "No version tags found, starting with v0.1.0"
            LATEST_TAG="v0.0.0"
          fi
          
          echo "Latest tag: $LATEST_TAG"
          
          # Extract version components
          VERSION_WITHOUT_V=${LATEST_TAG#v}
          IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION_WITHOUT_V"
          
          # Get commits since last tag
          if [ "$LATEST_TAG" = "v0.0.0" ]; then
            COMMITS=$(git log --oneline --pretty=format:"%s")
          else
            COMMITS=$(git log ${LATEST_TAG}..HEAD --oneline --pretty=format:"%s")
          fi
          
          echo "Commits since last tag:"
          echo "$COMMITS"
          
          # Analyze commit messages for version increment
          HAS_BREAKING_CHANGE=false
          HAS_FEAT=false
          HAS_BUGFIX=false
          
          while IFS= read -r commit; do
            commit_lower=$(echo "$commit" | tr '[:upper:]' '[:lower:]')
            
            # Check for breaking changes
            if echo "$commit_lower" | grep -E "(breaking|break|major)" > /dev/null; then
              HAS_BREAKING_CHANGE=true
            fi
            
            # Check for features
            if echo "$commit_lower" | grep -E "(feat|feature|minor)" > /dev/null; then
              HAS_FEAT=true
            fi
            
            # Check for bugfixes
            if echo "$commit_lower" | grep -E "(fix|bugfix|patch)" > /dev/null; then
              HAS_BUGFIX=true
            fi
          done <<< "$COMMITS"
          
          # Determine version increment
          if [ "$HAS_BREAKING_CHANGE" = true ]; then
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
            INCREMENT_TYPE="major"
          elif [ "$HAS_FEAT" = true ]; then
            MINOR=$((MINOR + 1))
            PATCH=0
            INCREMENT_TYPE="minor"
          elif [ "$HAS_BUGFIX" = true ]; then
            PATCH=$((PATCH + 1))
            INCREMENT_TYPE="patch"
          else
            echo "No version increment needed"
            echo "should_tag=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          NEW_VERSION="v${MAJOR}.${MINOR}.${PATCH}"
          
          echo "Version increment type: $INCREMENT_TYPE"
          echo "New version: $NEW_VERSION"
          
          # Set outputs
          echo "should_tag=true" >> $GITHUB_OUTPUT
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "increment_type=$INCREMENT_TYPE" >> $GITHUB_OUTPUT
          echo "latest_tag=$LATEST_TAG" >> $GITHUB_OUTPUT

      - name: Create and push new version tag
        if: steps.version.outputs.should_tag == 'true'
        run: |
          NEW_VERSION="${{ steps.version.outputs.new_version }}"
          INCREMENT_TYPE="${{ steps.version.outputs.increment_type }}"
          
          echo "Creating new tag: $NEW_VERSION (increment: $INCREMENT_TYPE)"
          
          # Create annotated tag with message
          git tag -a "$NEW_VERSION" -m "Release $NEW_VERSION - $INCREMENT_TYPE version bump
          
          Previous version: ${{ steps.version.outputs.latest_tag }}
          Increment type: $INCREMENT_TYPE
          
          Generated by GitHub Actions on $(date)"
          
          # Push the tag
          git push origin "$NEW_VERSION"
          
          echo "Successfully created and pushed tag: $NEW_VERSION"

      - name: Add job summary
        if: always()
        run: |
          echo "# ðŸš€ CI Workflow Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ steps.version.outputs.should_tag }}" = "true" ]; then
            echo "## âœ… New Version Created" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**New Version:** \`${{ steps.version.outputs.new_version }}\`" >> $GITHUB_STEP_SUMMARY
            echo "**Previous Version:** \`${{ steps.version.outputs.latest_tag }}\`" >> $GITHUB_STEP_SUMMARY
            echo "**Increment Type:** \`${{ steps.version.outputs.increment_type }}\`" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "The new version tag has been successfully created and pushed to the repository." >> $GITHUB_STEP_SUMMARY
          else
            echo "## â„¹ï¸ No Version Update" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "No version increment was needed based on the commit messages since the last tag." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Current Version:** \`${{ steps.version.outputs.latest_tag || 'No tags found' }}\`" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "*Generated on $(date)*" >> $GITHUB_STEP_SUMMARY

      - name: Install pnpm
        run: |
          corepack enable
          corepack prepare pnpm@latest --activate

      - name: Use Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: "pnpm"

      - name: Cache pnpm store
        uses: actions/cache@v4
        with:
          path: ~/.pnpm-store
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: Install dependencies
        run: pnpm install --frozen-lockfile --reporter=silent

      - name: Run lint
        run: pnpm lint

      - name: Build
        env:
          NODE_ENV: production
          NEXT_PUBLIC_CONVEX_URL: ${{ secrets.NEXT_PUBLIC_CONVEX_URL }}
        run: pnpm build
      
      - name: Deploy to Development
        # only run on push to main
        if: github.ref == 'refs/heads/main' 
        run:
          echo "Deploying to Development environment...
